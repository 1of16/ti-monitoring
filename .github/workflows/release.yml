name: Release Pipeline

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version (z.B. 1.2.3)'
        required: true
        type: string
      prerelease:
        description: 'Als Pre-Release erstellen'
        required: false
        type: boolean
        default: true

env:
  PYTHON_VERSION: '3.12'

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Install Dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        
    - name: Run Tests
      run: |
        # Hier können Tests hinzugefügt werden
        echo "Tests würden hier laufen"
        
  build-portable:
    needs: test
    runs-on: windows-latest
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Install Dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        
    - name: Create Portable Build
      run: |
        # Erstelle portable-build Verzeichnis
        $StageDir = "portable-build"
        if (Test-Path $StageDir) { Remove-Item $StageDir -Recurse -Force }
        New-Item -ItemType Directory -Path $StageDir | Out-Null
        
        # Kopiere Repository-Inhalt (ohne .git, node_modules, etc.)
        $excludeDirs = @('.git','node_modules','.venv','portable-build','dist','build','out','.mypy_cache','.pytest_cache','.ruff_cache','__pycache__')
        $excludeFiles = @('.DS_Store')
        
        $src = (Get-Location).Path
        $dst = (Resolve-Path -LiteralPath $StageDir).Path
        
        $excludeDirsArgs = @()
        foreach ($d in $excludeDirs) { $excludeDirsArgs += @('/XD', (Join-Path $src $d)) }
        $excludeFilesArgs = @()
        foreach ($f in $excludeFiles) { $excludeFilesArgs += @('/XF', (Join-Path $src $f)) }
        
        $args = @($src, $dst, '/E') + $excludeDirsArgs + $excludeFilesArgs
        $rc = Start-Process -FilePath robocopy -ArgumentList $args -NoNewWindow -PassThru -Wait
        if ($rc.ExitCode -gt 7) { throw "Robocopy fehlgeschlagen (ExitCode=$($rc.ExitCode))" }
        
        # Beispielkonfigurationen übernehmen
        Push-Location -LiteralPath $StageDir
        try {
          if ((Test-Path 'config.yaml.example' -PathType Leaf) -and -not (Test-Path 'config.yaml')) {
              Copy-Item 'config.yaml.example' 'config.yaml'
          }
          if ((Test-Path 'notifications.json.example' -PathType Leaf) -and -not (Test-Path 'notifications.json')) {
              Copy-Item 'notifications.json.example' 'notifications.json'
          }
        }
        finally { Pop-Location }
        
        # data/ Verzeichnis sicherstellen
        $dataStage = Join-Path $StageDir 'data'
        if (-not (Test-Path -LiteralPath $dataStage)) {
            New-Item -ItemType Directory -Path $dataStage | Out-Null
        }
        if (Test-Path -LiteralPath 'data' -PathType Container) {
            $rc = Start-Process -FilePath robocopy -ArgumentList @('data', $dataStage, '/E') -NoNewWindow -PassThru -Wait
            if ($rc.ExitCode -gt 7) { throw "Robocopy (data) fehlgeschlagen (ExitCode=$($rc.ExitCode))" }
        }
        
        # tools/ Verzeichnis sicherstellen
        $toolsStage = Join-Path $StageDir 'tools'
        if (-not (Test-Path -LiteralPath $toolsStage)) {
            New-Item -ItemType Directory -Path $toolsStage | Out-Null
        }
        if (Test-Path -LiteralPath 'tools' -PathType Container) {
            $rc = Start-Process -FilePath robocopy -ArgumentList @('tools', $toolsStage, '/E') -NoNewWindow -PassThru -Wait
            if ($rc.ExitCode -gt 7) { throw "Robocopy (tools) fehlgeschlagen (ExitCode=$($rc.ExitCode))" }
        }
        
        # venv erstellen und Requirements installieren
        $venvPath = Join-Path $StageDir '.venv'
        
        # Lösche alte venv falls vorhanden
        if (Test-Path -LiteralPath $venvPath) {
            Remove-Item -LiteralPath $venvPath -Recurse -Force
        }
        
        # Erstelle neue venv mit relativen Pfaden
        Write-Host "Erstelle portable venv..."
        Write-Host "Staging-Verzeichnis: $StageDir"
        Write-Host "Venv-Pfad: $venvPath"
        
        # Wechsle ins Staging-Verzeichnis
        Push-Location -LiteralPath $StageDir
        try {
            Write-Host "Aktuelles Verzeichnis: $(Get-Location)"
            
            # Verwende python -m venv mit --copies um relative Pfade zu erzwingen
            Write-Host "Erstelle venv mit --copies Flag..."
            python -m venv .venv --copies
            
            # Prüfe ob venv erstellt wurde
            if (-not (Test-Path -LiteralPath '.venv')) {
                throw "Venv-Verzeichnis wurde nicht erstellt"
            }
            
            $pip = Join-Path '.venv' 'Scripts\python.exe'
            Write-Host "Pip-Pfad: $pip"
            if (-not (Test-Path -LiteralPath $pip)) { 
                Write-Host "Verfügbare Dateien in .venv:"
                Get-ChildItem -LiteralPath '.venv' -Recurse | Select-Object FullName
                throw "Venv wurde nicht korrekt erstellt: $pip"
            }
            
            # Repariere pyvenv.cfg für portable Verwendung
            $pyvenvCfg = Join-Path '.venv' 'pyvenv.cfg'
            if (Test-Path -LiteralPath $pyvenvCfg) {
                $pyvenvContent = "home = .`ninclude-system-site-packages = false`nversion = 3.12.10`nexecutable = .\Scripts\python.exe`ncommand = .\Scripts\python.exe -m venv ."
                $pyvenvContent | Out-File -FilePath $pyvenvCfg -Encoding UTF8
                Write-Host "pyvenv.cfg für portable Verwendung konfiguriert"
            }
            
            # Repariere Python-Executables in der venv
            Write-Host "Repariere Python-Executables für portable Verwendung..."
            $pythonExe = Join-Path '.venv' 'Scripts\python.exe'
            $pythonwExe = Join-Path '.venv' 'Scripts\pythonw.exe'
            
            # Kopiere Python-Executables von der System-Installation
            $systemPython = (Get-Command python).Source
            if (Test-Path -LiteralPath $systemPython) {
                Copy-Item -LiteralPath $systemPython -Destination $pythonExe -Force
                Write-Host "Python-Executable repariert: $pythonExe"
            }
            
            $systemPythonw = $systemPython -replace 'python.exe', 'pythonw.exe'
            if (Test-Path -LiteralPath $systemPythonw) {
                Copy-Item -LiteralPath $systemPythonw -Destination $pythonwExe -Force
                Write-Host "Pythonw-Executable repariert: $pythonwExe"
            }
            
            if (Test-Path -LiteralPath 'requirements.txt' -PathType Leaf) {
                Write-Host "Installiere Requirements in venv"
                Write-Host "Aktualisiere pip..."
                & $pip -m pip install --upgrade pip
                if ($LASTEXITCODE -ne 0) {
                    throw "pip upgrade fehlgeschlagen (ExitCode=$LASTEXITCODE)"
                }
                
                Write-Host "Installiere Requirements aus requirements.txt..."
                & $pip -m pip install -r 'requirements.txt' --no-cache-dir
                if ($LASTEXITCODE -ne 0) {
                    throw "Requirements-Installation fehlgeschlagen (ExitCode=$LASTEXITCODE)"
                }
                
                Write-Host "Validiere Installation wichtiger Pakete..."
                $criticalPackages = @('dash', 'plotly', 'requests', 'apprise', 'pandas', 'numpy')
                foreach ($pkg in $criticalPackages) {
                    try {
                        $result = & $pip show $pkg 2>&1
                        if ($LASTEXITCODE -eq 0) {
                            Write-Host "✓ $pkg installiert"
                        } else {
                            Write-Host "✗ $pkg nicht gefunden: $result"
                            throw "Kritisches Paket $pkg nicht installiert"
                        }
                    } catch {
                        Write-Host "✗ $pkg Validierung fehlgeschlagen: $_"
                        throw "Validierung von $pkg fehlgeschlagen"
                    }
                }
                
                Write-Host "Requirements-Installation und Validierung erfolgreich abgeschlossen"
            } else {
                Write-Host "requirements.txt nicht gefunden, überspringe Installation"
            }
        }
        finally {
            Pop-Location
        }
        
        # ZIP erstellen
        $timestamp = Get-Date -Format 'yyyyMMdd-HHmmss'
        $zipName = "ti-monitoring-portable-$timestamp.zip"
        $zipPath = Join-Path (Get-Location) $zipName
        Write-Host "Erzeuge ZIP: $zipPath"
        if (Test-Path -LiteralPath $zipPath) { Remove-Item -LiteralPath $zipPath -Force }
        Compress-Archive -Path $StageDir -DestinationPath $zipPath -Force
        
    - name: Upload Portable Build
      uses: actions/upload-artifact@v4
      with:
        name: ti-monitoring-portable-${{ github.ref_name }}
        path: ti-monitoring-portable-*.zip
        retention-days: 30
        
    - name: Create GitHub Release
      if: startsWith(github.ref, 'refs/tags/')
      uses: softprops/action-gh-release@v1
      with:
        files: ti-monitoring-portable-*.zip
        prerelease: ${{ github.event.inputs.prerelease == 'true' || contains(github.ref, 'alpha') || contains(github.ref, 'beta') || contains(github.ref, 'rc') }}
        generate_release_notes: true
        body: |
          ## TI-Monitoring Portable ${{ github.ref_name }}
          
          ### 🚀 Windows Portable Build
          - ✅ Vollständig portable Windows-Anwendung
          - ✅ Automatische Service-Installation mit NSSM
          - ✅ Virtuelle Python-Umgebung enthalten
          - ✅ Umfassende Installationsanleitung
          
          ### 📦 Installation
          1. ZIP-Datei entpacken
          2. `install-service.cmd` als Administrator ausführen
          3. Web-Interface unter http://localhost:8050 aufrufen
          
          ### ✨ Features
          - 🔍 Automatische TI-Service-Überwachung
          - 🌐 Web-basierte Benutzeroberfläche
          - 📧 Universelle Benachrichtigungsoptionen via Apprise
          - 📊 Detaillierte Statistiken und Logs
          
          ### 📋 Systemanforderungen
          - Windows 10/11 (64-bit)
          - Administratorrechte für Service-Installation
          - Internetverbindung für API-Updates
          
          ### 🔧 Support
          Bei Problemen siehe: [Installationsanleitung](docs/INSTALL_Windows_Portable.md)
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
  notify:
    needs: [test, build-portable]
    runs-on: ubuntu-latest
    if: always()
    steps:
    - name: Notify Success
      if: needs.build-portable.result == 'success'
      run: |
        echo "✅ Release erfolgreich erstellt: ${{ github.ref_name }}"
        
    - name: Notify Failure
      if: needs.build-portable.result == 'failure'
      run: |
        echo "❌ Release fehlgeschlagen: ${{ github.ref_name }}"

name: Manual Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version (z.B. 1.2.3)'
        required: true
        type: string
      prerelease:
        description: 'Als Pre-Release erstellen'
        required: false
        type: boolean
        default: true
      create_tag:
        description: 'Git Tag erstellen'
        required: false
        type: boolean
        default: true

jobs:
  create-release:
    runs-on: windows-latest
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.12'
        
    - name: Install Dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        
    - name: Create Git Tag
      if: ${{ github.event.inputs.create_tag == 'true' }}
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git tag -a "v${{ github.event.inputs.version }}" -m "Release version ${{ github.event.inputs.version }}"
        git push origin "v${{ github.event.inputs.version }}"
        
    - name: Create Portable Build
      run: |
        # Erstelle portable-build Verzeichnis
        $StageDir = "portable-build"
        if (Test-Path $StageDir) { Remove-Item $StageDir -Recurse -Force }
        New-Item -ItemType Directory -Path $StageDir | Out-Null
        
        # Kopiere Repository-Inhalt (ohne .git, node_modules, etc.)
        $excludeDirs = @('.git','node_modules','.venv','portable-build','dist','build','out','.mypy_cache','.pytest_cache','.ruff_cache','__pycache__')
        $excludeFiles = @('.DS_Store')
        
        $src = (Get-Location).Path
        $dst = (Resolve-Path -LiteralPath $StageDir).Path
        
        $excludeDirsArgs = @()
        foreach ($d in $excludeDirs) { $excludeDirsArgs += @('/XD', (Join-Path $src $d)) }
        $excludeFilesArgs = @()
        foreach ($f in $excludeFiles) { $excludeFilesArgs += @('/XF', (Join-Path $src $f)) }
        
        $args = @($src, $dst, '/E') + $excludeDirsArgs + $excludeFilesArgs
        $rc = Start-Process -FilePath robocopy -ArgumentList $args -NoNewWindow -PassThru -Wait
        if ($rc.ExitCode -gt 7) { throw "Robocopy fehlgeschlagen (ExitCode=$($rc.ExitCode))" }
        
        # Beispielkonfigurationen √ºbernehmen
        Push-Location -LiteralPath $StageDir
        try {
          if ((Test-Path 'config.yaml.example' -PathType Leaf) -and -not (Test-Path 'config.yaml')) {
              Copy-Item 'config.yaml.example' 'config.yaml'
          }
          if ((Test-Path 'notifications.json.example' -PathType Leaf) -and -not (Test-Path 'notifications.json')) {
              Copy-Item 'notifications.json.example' 'notifications.json'
          }
        }
        finally { Pop-Location }
        
        # data/ Verzeichnis sicherstellen
        $dataStage = Join-Path $StageDir 'data'
        if (-not (Test-Path -LiteralPath $dataStage)) {
            New-Item -ItemType Directory -Path $dataStage | Out-Null
        }
        if (Test-Path -LiteralPath 'data' -PathType Container) {
            $rc = Start-Process -FilePath robocopy -ArgumentList @('data', $dataStage, '/E') -NoNewWindow -PassThru -Wait
            if ($rc.ExitCode -gt 7) { throw "Robocopy (data) fehlgeschlagen (ExitCode=$($rc.ExitCode))" }
        }
        
        # tools/ Verzeichnis sicherstellen
        $toolsStage = Join-Path $StageDir 'tools'
        if (-not (Test-Path -LiteralPath $toolsStage)) {
            New-Item -ItemType Directory -Path $toolsStage | Out-Null
        }
        if (Test-Path -LiteralPath 'tools' -PathType Container) {
            $rc = Start-Process -FilePath robocopy -ArgumentList @('tools', $toolsStage, '/E') -NoNewWindow -PassThru -Wait
            if ($rc.ExitCode -gt 7) { throw "Robocopy (tools) fehlgeschlagen (ExitCode=$($rc.ExitCode))" }
        }
        
        # venv erstellen und Requirements installieren
        $venvPath = Join-Path $StageDir '.venv'
        python -m venv $venvPath
        
        $pip = Join-Path $venvPath 'Scripts\python.exe'
        if (-not (Test-Path -LiteralPath $pip)) { throw "Venv wurde nicht korrekt erstellt: $venvPath" }
        
        # venv f√ºr portable Verwendung reparieren
        Write-Host "Repariere venv f√ºr portable Verwendung..."
        $pyvenvCfg = Join-Path $venvPath 'pyvenv.cfg'
        if (Test-Path -LiteralPath $pyvenvCfg) {
            # Erstelle neue pyvenv.cfg mit relativen Pfaden
            $newPyvenvCfg = @"
home = .
include-system-site-packages = false
version = 3.12.10
executable = .\Scripts\python.exe
command = .\Scripts\python.exe -m venv .
"@
            $newPyvenvCfg | Out-File -FilePath $pyvenvCfg -Encoding UTF8
            Write-Host "pyvenv.cfg repariert"
        }
        
        $req = Join-Path $StageDir 'requirements.txt'
        if (Test-Path -LiteralPath $req -PathType Leaf) {
            Write-Host "Installiere Requirements in venv"
            & $pip -m pip install --upgrade pip
            & $pip -m pip install -r $req --no-cache-dir
            Write-Host "Requirements-Installation abgeschlossen"
        }
        
        # ZIP erstellen
        $timestamp = Get-Date -Format 'yyyyMMdd-HHmmss'
        $zipName = "ti-monitoring-portable-$timestamp.zip"
        $zipPath = Join-Path (Get-Location) $zipName
        Write-Host "Erzeuge ZIP: $zipPath"
        if (Test-Path -LiteralPath $zipPath) { Remove-Item -LiteralPath $zipPath -Force }
        Compress-Archive -Path $StageDir -DestinationPath $zipPath -Force
        
    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: v${{ github.event.inputs.version }}
        name: TI-Monitoring Portable v${{ github.event.inputs.version }}
        files: ti-monitoring-portable-*.zip
        prerelease: ${{ github.event.inputs.prerelease == 'true' }}
        generate_release_notes: true
        body: |
          ## TI-Monitoring Portable v${{ github.event.inputs.version }}
          
          ### üöÄ Windows Portable Build
          - ‚úÖ Vollst√§ndig portable Windows-Anwendung
          - ‚úÖ Automatische Service-Installation mit NSSM
          - ‚úÖ Virtuelle Python-Umgebung enthalten
          - ‚úÖ Umfassende Installationsanleitung
          
          ### üì¶ Installation
          1. ZIP-Datei entpacken
          2. `install-service.cmd` als Administrator ausf√ºhren
          3. Web-Interface unter http://localhost:8050 aufrufen
          
          ### ‚ú® Features
          - üîç Automatische TI-Service-√úberwachung
          - üåê Web-basierte Benutzeroberfl√§che
          - üìß Universelle Benachrichtigungsoptionen via Apprise
          - üìä Detaillierte Statistiken und Logs
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
